<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Detecting event loop blocking in asyncio | deepankar.log</title><meta name=keywords content="python,asyncio,fastapi,performance,pyleak"><meta name=description content="How to find sync code silently blocking your asyncio app"><meta name=author content="Deepankar Mahapatro"><link rel=canonical href=https://deepankarm.github.io/posts/detecting-event-loop-blocking-in-asyncio/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://deepankarm.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://deepankarm.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://deepankarm.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://deepankarm.github.io/apple-touch-icon.png><link rel=mask-icon href=https://deepankarm.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://deepankarm.github.io/posts/detecting-event-loop-blocking-in-asyncio/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "09cbd7674917411283ca3c61ea31135d"}'></script><meta property="og:url" content="https://deepankarm.github.io/posts/detecting-event-loop-blocking-in-asyncio/"><meta property="og:site_name" content="deepankar.log"><meta property="og:title" content="Detecting event loop blocking in asyncio"><meta property="og:description" content="How to find sync code silently blocking your asyncio app"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-11T14:00:00+05:30"><meta property="article:modified_time" content="2026-01-11T14:00:00+05:30"><meta property="article:tag" content="python"><meta property="article:tag" content="asyncio"><meta property="article:tag" content="fastapi"><meta property="article:tag" content="performance"><meta property="article:tag" content="pyleak"><meta name=twitter:card content="summary"><meta name=twitter:title content="Detecting event loop blocking in asyncio"><meta name=twitter:description content="How to find sync code silently blocking your asyncio app"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"posts","item":"https://deepankarm.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Detecting event loop blocking in asyncio","item":"https://deepankarm.github.io/posts/detecting-event-loop-blocking-in-asyncio/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Detecting event loop blocking in asyncio","name":"Detecting event loop blocking in asyncio","description":"How to find sync code silently blocking your asyncio app","keywords":["python","asyncio","fastapi","performance","pyleak"],"articleBody":" If you’re writing async Python, you’ve probably blocked the event loop without knowing it. Your code runs. Your tests pass. But in production, p90 latencies spike and timeouts appear seemingly at random.\nThe culprit? Synchronous code hiding inside your async def functions. Python’s asyncio is cooperative. When you await something, you’re yielding control back to the event loop so other tasks can run. But if you call synchronous code, even accidentally, the entire event loop freezes. Every other coroutine waits. Every concurrent request hangs. Every other user gets blocked.\nThe insidious part: the code looks perfectly fine.\nasync def fetch_user_preferences(user_id: str) -\u003e dict: config = boto3.client('ssm').get_parameter(Name=f'/users/{user_id}/prefs') return json.loads(config['Parameter']['Value']) This function is async. It’s called with await. Your IDE shows no warnings. Your linter is silent. But boto3 is entirely synchronous- every call blocks the event loop until the network round-trip completes.\nAI Agents Make This Worse AI agents orchestrate multiple LLM calls, tool executions, and API requests concurrently. They’re built on asyncio because concurrency is essential. But agent code is also where blocking bugs hide best:\nasync def run_agent_step(state: AgentState) -\u003e AgentState: response = await llm.chat(state.messages) parsed = json.loads(response.content) # Might block on large payloads for tool_call in parsed.get('tool_calls', []): result = some_tool_sdk.execute(tool_call) # Blocks state.messages.append(result) return state When you’re running 50 concurrent agent sessions, one blocking call doesn’t just slow down one user, it freezes all 50. Many agent frameworks don’t handle this properly. They’ll wrap your tools in async def but won’t offload the actual blocking work to threads. The tool looks async, behaves sync.\nThe Usual Suspects Linters catch time.sleep(). They don’t catch these:\nCPU-bound work:\ndoc = fitz.open(stream=content, filetype='pdf') text = page.get_text() Synchronous HTTP clients:\nresponse = requests.get(url) File I/O:\nwith open('large_file.bin', 'rb') as f: data = f.read() Cloud SDKs:\ns3_client.put_object(Bucket=bucket, Key=key, Body=data) ORMs and database drivers:\nsession.query(User).filter_by(id=user_id).first() The pattern is always the same: the function is async, it’s awaited correctly, but somewhere inside, synchronous code runs.\nDetecting Blocking with pyleak pyleak detects event loop blocking and gives you a stack trace pointing to exactly where it happens.\nfrom pyleak import no_event_loop_blocking @pytest.mark.asyncio async def test_blocking_detected(): async with no_event_loop_blocking(action=\"raise\", threshold=0.01): await client.post(\"/ingest\", files={\"file\": pdf_bytes}) When blocking exceeds the threshold:\nEvent Loop Block: block-1 Duration: 0.010s (threshold: 0.010s) Blocking Stack: ... File \"app.py\", line 86, in ingest _upload_to_s3(s3_key, img_bytes, f\"image/{ext}\") File \"app.py\", line 60, in _upload_to_s3 s3_client.put_object( The stack trace shows s3_client.put_object is the blocker.\nThe Results I built a simple PDF ingestion service that extracts text and images from PDFs, then uploads to S3, a common pattern in RAG. The blocking version uses sync fitz and boto3 calls directly. The async version wraps them in asyncio.to_thread().\nLoad testing with 100 and 1000 concurrent requests:\n100 concurrent requests:\nBlocking: p99: 3.86s | 25.8 RPS Async: p99: 2.93s | 33.7 RPS Improvement: +31% throughput, -24% p99 latency 1000 concurrent requests:\nBlocking: p99: 41.21s | 23.9 RPS Async: p99: 30.20s | 32.5 RPS Improvement: +36% throughput, -27% p99 latency Adding to Your Test Suite pyleak includes a pytest plugin. Add the marker to detect blocking automatically:\n@pytest.mark.no_leaks(blocking=True, blocking_threshold=0.1) @pytest.mark.asyncio async def test_no_blocking(): await your_async_function() Now any blocking over your threshold fails the test with a stack trace.\nTL;DR Sync code inside async def blocks the entire event loop Linters don’t catch it, tests pass, production breaks Common culprits: boto3, requests, file I/O, ORMs, PDF libraries pyleak detects blocking and shows you exactly where pip install pyleak ","wordCount":"567","inLanguage":"en","datePublished":"2026-01-11T14:00:00+05:30","dateModified":"2026-01-11T14:00:00+05:30","author":{"@type":"Person","name":"Deepankar Mahapatro"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://deepankarm.github.io/posts/detecting-event-loop-blocking-in-asyncio/"},"publisher":{"@type":"Organization","name":"deepankar.log","logo":{"@type":"ImageObject","url":"https://deepankarm.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://deepankarm.github.io/ accesskey=h title="deepankar.log (Alt + H)">deepankar.log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://deepankarm.github.io/ title=Home><span>Home</span></a></li><li><a href=https://deepankarm.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://deepankarm.github.io/about/ title=About><span>About</span></a></li><li><a href=https://github.com/deepankarm title=GitHub><span>GitHub</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.linkedin.com/in/deepankar-mahapatro/ title=LinkedIn><span>LinkedIn</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Detecting event loop blocking in asyncio</h1><div class=post-description>How to find sync code silently blocking your asyncio app</div><div class=post-meta><span title='2026-01-11 14:00:00 +0530 +0530'>January 11, 2026</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Deepankar Mahapatro</span></div></header><div class=post-content><hr><p>If you&rsquo;re writing async Python, you&rsquo;ve probably blocked the event loop without knowing it. Your code runs. Your tests pass. But in production, p90 latencies spike and timeouts appear seemingly at random.</p><p>The culprit? Synchronous code hiding inside your <code>async def</code> functions. Python&rsquo;s <code>asyncio</code> is cooperative. When you <code>await</code> something, you&rsquo;re yielding control back to the event loop so other tasks can run. But if you call synchronous code, even accidentally, the entire event loop freezes. Every other coroutine waits. Every concurrent request hangs. Every other user gets blocked.</p><p>The insidious part: <strong>the code looks perfectly fine</strong>.</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#c678dd>async</span> <span style=color:#c678dd>def</span> <span style=color:#61afef;font-weight:700>fetch_user_preferences</span>(<span style=color:#e06c75>user_id</span>: <span style=color:#e5c07b>str</span>) <span style=color:#56b6c2>-&gt;</span> <span style=color:#e5c07b>dict</span>:
</span></span><span style=display:flex><span>    <span style=color:#e06c75>config</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>boto3</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>client</span>(<span style=color:#98c379>&#39;ssm&#39;</span>)<span style=color:#56b6c2>.</span><span style=color:#e06c75>get_parameter</span>(<span style=color:#e06c75>Name</span><span style=color:#56b6c2>=</span><span style=color:#98c379>f</span><span style=color:#98c379>&#39;/users/</span><span style=color:#98c379>{</span><span style=color:#e06c75>user_id</span><span style=color:#98c379>}</span><span style=color:#98c379>/prefs&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#c678dd>return</span> <span style=color:#e06c75>json</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>loads</span>(<span style=color:#e06c75>config</span>[<span style=color:#98c379>&#39;Parameter&#39;</span>][<span style=color:#98c379>&#39;Value&#39;</span>])
</span></span></code></pre></div><p>This function is <code>async</code>. It&rsquo;s called with <code>await</code>. Your IDE shows no warnings. Your linter is silent. But <code>boto3</code> is entirely synchronous- every call blocks the event loop until the network round-trip completes.</p><hr><h2 id=ai-agents-make-this-worse>AI Agents Make This Worse<a hidden class=anchor aria-hidden=true href=#ai-agents-make-this-worse>#</a></h2><p>AI agents orchestrate multiple LLM calls, tool executions, and API requests concurrently. They&rsquo;re built on asyncio because concurrency is essential. But agent code is also where blocking bugs hide best:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#c678dd>async</span> <span style=color:#c678dd>def</span> <span style=color:#61afef;font-weight:700>run_agent_step</span>(<span style=color:#e06c75>state</span>: <span style=color:#e06c75>AgentState</span>) <span style=color:#56b6c2>-&gt;</span> <span style=color:#e06c75>AgentState</span>:
</span></span><span style=display:flex><span>    <span style=color:#e06c75>response</span> <span style=color:#56b6c2>=</span> <span style=color:#c678dd>await</span> <span style=color:#e06c75>llm</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>chat</span>(<span style=color:#e06c75>state</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>messages</span>)
</span></span><span style=display:flex><span>    <span style=color:#e06c75>parsed</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>json</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>loads</span>(<span style=color:#e06c75>response</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>content</span>)  <span style=color:#7f848e># Might block on large payloads</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>for</span> <span style=color:#e06c75>tool_call</span> <span style=color:#56b6c2>in</span> <span style=color:#e06c75>parsed</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>get</span>(<span style=color:#98c379>&#39;tool_calls&#39;</span>, []):
</span></span><span style=display:flex><span>        <span style=color:#e06c75>result</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>some_tool_sdk</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>execute</span>(<span style=color:#e06c75>tool_call</span>)  <span style=color:#7f848e># Blocks</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>state</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>messages</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>append</span>(<span style=color:#e06c75>result</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>return</span> <span style=color:#e06c75>state</span>
</span></span></code></pre></div><p>When you&rsquo;re running 50 concurrent agent sessions, one blocking call doesn&rsquo;t just slow down one user, it freezes all 50. Many agent frameworks don&rsquo;t handle this properly. They&rsquo;ll wrap your tools in <code>async def</code> but won&rsquo;t offload the actual blocking work to threads. The tool looks async, behaves sync.</p><hr><h2 id=the-usual-suspects>The Usual Suspects<a hidden class=anchor aria-hidden=true href=#the-usual-suspects>#</a></h2><p>Linters catch <code>time.sleep()</code>. They don&rsquo;t catch these:</p><p><strong>CPU-bound work:</strong></p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#e06c75>doc</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>fitz</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>open</span>(<span style=color:#e06c75>stream</span><span style=color:#56b6c2>=</span><span style=color:#e06c75>content</span>, <span style=color:#e06c75>filetype</span><span style=color:#56b6c2>=</span><span style=color:#98c379>&#39;pdf&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#e06c75>text</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>page</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>get_text</span>()
</span></span></code></pre></div><p><strong>Synchronous HTTP clients:</strong></p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#e06c75>response</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>requests</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>get</span>(<span style=color:#e06c75>url</span>)
</span></span></code></pre></div><p><strong>File I/O:</strong></p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#c678dd>with</span> <span style=color:#e5c07b>open</span>(<span style=color:#98c379>&#39;large_file.bin&#39;</span>, <span style=color:#98c379>&#39;rb&#39;</span>) <span style=color:#c678dd>as</span> <span style=color:#e06c75>f</span>:
</span></span><span style=display:flex><span>    <span style=color:#e06c75>data</span> <span style=color:#56b6c2>=</span> <span style=color:#e06c75>f</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>read</span>()
</span></span></code></pre></div><p><strong>Cloud SDKs:</strong></p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#e06c75>s3_client</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>put_object</span>(<span style=color:#e06c75>Bucket</span><span style=color:#56b6c2>=</span><span style=color:#e06c75>bucket</span>, <span style=color:#e06c75>Key</span><span style=color:#56b6c2>=</span><span style=color:#e06c75>key</span>, <span style=color:#e06c75>Body</span><span style=color:#56b6c2>=</span><span style=color:#e06c75>data</span>)
</span></span></code></pre></div><p><strong>ORMs and database drivers:</strong></p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#e06c75>session</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>query</span>(<span style=color:#e06c75>User</span>)<span style=color:#56b6c2>.</span><span style=color:#e06c75>filter_by</span>(<span style=color:#e5c07b>id</span><span style=color:#56b6c2>=</span><span style=color:#e06c75>user_id</span>)<span style=color:#56b6c2>.</span><span style=color:#e06c75>first</span>()
</span></span></code></pre></div><p>The pattern is always the same: the function is <code>async</code>, it&rsquo;s awaited correctly, but somewhere inside, synchronous code runs.</p><hr><h2 id=detecting-blocking-with-pyleak>Detecting Blocking with pyleak<a hidden class=anchor aria-hidden=true href=#detecting-blocking-with-pyleak>#</a></h2><p><a href=https://github.com/deepankarm/pyleak>pyleak</a> detects event loop blocking and gives you a stack trace pointing to exactly where it happens.</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#c678dd>from</span> <span style=color:#e06c75>pyleak</span> <span style=color:#c678dd>import</span> <span style=color:#e06c75>no_event_loop_blocking</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#61afef>@pytest.mark.asyncio</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>async</span> <span style=color:#c678dd>def</span> <span style=color:#61afef;font-weight:700>test_blocking_detected</span>():
</span></span><span style=display:flex><span>    <span style=color:#c678dd>async</span> <span style=color:#c678dd>with</span> <span style=color:#e06c75>no_event_loop_blocking</span>(<span style=color:#e06c75>action</span><span style=color:#56b6c2>=</span><span style=color:#98c379>&#34;raise&#34;</span>, <span style=color:#e06c75>threshold</span><span style=color:#56b6c2>=</span><span style=color:#d19a66>0.01</span>):
</span></span><span style=display:flex><span>        <span style=color:#c678dd>await</span> <span style=color:#e06c75>client</span><span style=color:#56b6c2>.</span><span style=color:#e06c75>post</span>(<span style=color:#98c379>&#34;/ingest&#34;</span>, <span style=color:#e06c75>files</span><span style=color:#56b6c2>=</span>{<span style=color:#98c379>&#34;file&#34;</span>: <span style=color:#e06c75>pdf_bytes</span>})
</span></span></code></pre></div><p>When blocking exceeds the threshold:</p><pre tabindex=0><code>Event Loop Block: block-1
  Duration: 0.010s (threshold: 0.010s)
  Blocking Stack:
      ...
      File &#34;app.py&#34;, line 86, in ingest
          _upload_to_s3(s3_key, img_bytes, f&#34;image/{ext}&#34;)
      File &#34;app.py&#34;, line 60, in _upload_to_s3
          s3_client.put_object(
</code></pre><p>The stack trace shows <code>s3_client.put_object</code> is the blocker.</p><hr><h2 id=the-results>The Results<a hidden class=anchor aria-hidden=true href=#the-results>#</a></h2><p>I built a simple <a href=https://github.com/deepankarm/pyleak/tree/main/examples/event_loop_detection>PDF ingestion service</a> that extracts text and images from PDFs, then uploads to S3, a common pattern in RAG. The blocking version uses sync <code>fitz</code> and <code>boto3</code> calls directly. The async version wraps them in <code>asyncio.to_thread()</code>.</p><p>Load testing with 100 and 1000 concurrent requests:</p><p><strong>100 concurrent requests:</strong></p><p align=center><img src=https://raw.githubusercontent.com/deepankarm/pyleak/main/examples/event_loop_detection/scripts/results_100.png alt="Results for 100 requests" width=90%></p><pre tabindex=0><code>Blocking:  p99: 3.86s  |  25.8 RPS
Async:     p99: 2.93s  |  33.7 RPS

Improvement: +31% throughput, -24% p99 latency
</code></pre><p><strong>1000 concurrent requests:</strong></p><p align=center><img src=https://raw.githubusercontent.com/deepankarm/pyleak/main/examples/event_loop_detection/scripts/results_1000.png alt="Results for 1000 requests" width=90%></p><pre tabindex=0><code>Blocking:  p99: 41.21s  |  23.9 RPS
Async:     p99: 30.20s  |  32.5 RPS

Improvement: +36% throughput, -27% p99 latency
</code></pre><hr><h2 id=adding-to-your-test-suite>Adding to Your Test Suite<a hidden class=anchor aria-hidden=true href=#adding-to-your-test-suite>#</a></h2><p>pyleak includes a pytest plugin. Add the marker to detect blocking automatically:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#61afef>@pytest.mark.no_leaks</span>(<span style=color:#e06c75>blocking</span><span style=color:#56b6c2>=</span><span style=color:#e5c07b>True</span>, <span style=color:#e06c75>blocking_threshold</span><span style=color:#56b6c2>=</span><span style=color:#d19a66>0.1</span>)
</span></span><span style=display:flex><span><span style=color:#61afef>@pytest.mark.asyncio</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>async</span> <span style=color:#c678dd>def</span> <span style=color:#61afef;font-weight:700>test_no_blocking</span>():
</span></span><span style=display:flex><span>    <span style=color:#c678dd>await</span> <span style=color:#e06c75>your_async_function</span>()
</span></span></code></pre></div><p>Now any blocking over your threshold fails the test with a stack trace.</p><hr><h2 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><ul><li>Sync code inside <code>async def</code> blocks the entire event loop</li><li>Linters don&rsquo;t catch it, tests pass, production breaks</li><li>Common culprits: <code>boto3</code>, <code>requests</code>, file I/O, ORMs, PDF libraries</li><li><a href=https://github.com/deepankarm/pyleak>pyleak</a> detects blocking and shows you exactly where</li></ul><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pip install pyleak
</span></span></code></pre></div><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://deepankarm.github.io/tags/python/>python</a></li><li><a href=https://deepankarm.github.io/tags/asyncio/>asyncio</a></li><li><a href=https://deepankarm.github.io/tags/fastapi/>fastapi</a></li><li><a href=https://deepankarm.github.io/tags/performance/>performance</a></li><li><a href=https://deepankarm.github.io/tags/pyleak/>pyleak</a></li></ul><nav class=paginav><a class=prev href=https://deepankarm.github.io/posts/pydantic-for-go-validating-llm-outputs-with-godantic/><span class=title>« Prev</span><br><span>Pydantic for Go: Validating LLM Outputs with godantic</span>
</a><a class=next href=https://deepankarm.github.io/posts/openai-compatibility-paradox/><span class=title>Next »</span><br><span>The OpenAI Compatibility Paradox</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://deepankarm.github.io/>deepankar.log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>