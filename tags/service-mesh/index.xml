<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>service-mesh on Deepankar's Tech Blogs</title><link>http://deepankarm.github.io/tags/service-mesh/</link><description>Recent content in service-mesh on Deepankar's Tech Blogs</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 16 Jun 2022 12:49:55 +0530</lastBuildDate><atom:link href="http://deepankarm.github.io/tags/service-mesh/index.xml" rel="self" type="application/rss+xml"/><item><title>Jina ü§ù Linkerd</title><link>http://deepankarm.github.io/posts/jina-linkerd/</link><pubDate>Thu, 16 Jun 2022 12:49:55 +0530</pubDate><guid>http://deepankarm.github.io/posts/jina-linkerd/</guid><description>Let&amp;rsquo;s discuss today about a way to find bottlenecks in your Executors &amp;amp; Flows using Linkerd service mesh.
What is a Service Mesh? From Linkerd docs
A service mesh is a tool for adding observability, security, and reliability features to ‚Äúcloud native‚Äù applications by transparently inserting this functionality at the platform layer rather than the application layer.
Few of the commonly used service meshes are Linkerd, Istio, Consul etc.
Why Linkerd?</description></item></channel></rss>